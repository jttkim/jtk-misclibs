#include <stdlib.h>
#include <string.h>

#include "gnlibin.h"


/*
 * Create a new tree node that is an offspring of node specified
 * by p_ancestor. Name is optional, a NULL pointer can be passed
 * if it is not needed. The ID of the new node is generated by
 * gn_new_treenode and passed back to the caller via new_nid.
 * Return: 0 upon success, negative error code otherwise.
 */

int gn_new_treenode(GN_TREE *gtree, const GN_NODE_ID *p_ancestor_id, long generation, const char *name, const char *genome, GN_NODE_ID *new_nid)
{
  GN_NODE *gn, *p_ancestor;
  int return_code;
  char *gbuf;

  new_nid->generation = generation;
  if (gtree->last_id.generation == generation)
    new_nid->id = ++gtree->last_id.id;
  else if (gtree->last_id.generation < generation)
  {
    new_nid->id = 0;
    gtree->last_id.generation = generation;
    gtree->last_id.id = 0;
  }
  else
    return (GNERR_IDGENERATION);
  if (genome && *genome)
  {
    gbuf = (char *) malloc(strlen(genome) + 1);
    if (gbuf == NULL)
      return (GNERR_MEM);
    strcpy(gbuf, genome);
  }
  else
    gbuf = NULL;
  if ((return_code = gn_add_treenode(gtree, new_nid, p_ancestor_id, &gn)) < 0)
    return (return_code);
  if ((return_code = gn_addtonlist(&(gtree->alive_list), gn)) < 0)
  {
    gn_remove_treenode(gtree, gn);
    return (return_code);
  }
  gtree->num_alive++;
  gn->branch_generation = generation;
  gn->lifespan = GN_STILL_ALIVE;
  gn->num_alive = 1;
  if (name)
  {
    strncpy(gn->name, name, GN_MAX_NODENAME_LENGTH);
    gn->name[GN_MAX_NODENAME_LENGTH] = '\0';
  }
  else
    gn->name[0] = '\0';
  gn->genome = gbuf;
  p_ancestor = gn->ancestor;
  while (p_ancestor)
  {
    p_ancestor->num_alive++;
    p_ancestor = p_ancestor->ancestor;
  }
  return (0);
}

