#include <ctype.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ptlibin.h"


#ifndef PI
#  define PI 3.1415927
#endif


void read_string(char *s, long l, FILE *f)
{
  long i;

  s[0] = '\0';
  while (s[0] == '\0')
  {
    fgets(s, l, f);
    if (s[0] == '#')
      s[0] = '\0';
    else
    {
      i = strlen(s) - 1;
      if (s[i] == '\n')
        s[i] = '\0';
    }
    if (ferror(f) || feof(f))
      return;
  }
}


const PHYL_LEAFATTRIBUTE *phyl_find_leafattr(const char *name, const PHYL_LEAFATTRIBUTE *attrlist)
{
  const PHYL_LEAFATTRIBUTE *a;

  for (a = attrlist; a; a = a->next)
  {
    if (!strcmp(name, a->name))
      break;
  }
  return (a);
}


/*
 * Automatically generate rgb colors for leaves that
 * were specified to be colored but no color was explicitly
 * specified. Colors are generated by selecting equidistant
 * points from the circle in rgb space that exactly fits
 * into the triangle with the corners (1, 0, 0), (0, 1, 0)
 * and (0, 0, 1).
 */

void phyl_compute_leafcolors(PHYL_LEAFATTRIBUTE *attrlist)
{
  PHYL_LEAFATTRIBUTE *a, *a1;
  long num_computed = 0;
  double xr, xg, xb, yr, yg, yb, radius, x, y, angle, intensity;

  intensity = 1.0;
  a = attrlist;
  while (a)
  {
    if (a->red == -1.0)
    {
      a->red = -2 - num_computed;
      a->green = intensity;
      a1 = a->next;
      while (a1)
      {
        if ((a1->red == -1.0) && !strcmp(a->class, a1->class))
        {
          a1->red = -2 - num_computed;
          a1->green = intensity;
        }
        a1 = a1->next;
      }
      if (intensity)
        intensity = 0.0;
      else
        intensity = 1.0;
      num_computed++;
    }
    a = a->next;
  }
  if (num_computed == 0)
    return;
  radius = sqrt(0.5) * tan(0.1666667 * PI);
  xr = 1.0 / sqrt(2.0);
  xg = -xr;
  xb = 0.0;
  yr = -1.0 / sqrt(6.0);
  yg = yr;
  yb = -2.0 * yr;
  a = attrlist;
  while (a)
  {
    if (a->red < -1.0)
    {
      angle = -(a->red + 2) / num_computed * PI * 2.0;
      intensity = a->green;
      x = radius * cos(angle);
      y = radius * sin(angle);
      if (intensity)
      {
        a->red = x * xr + y * yr + 0.5;
        a->green = x * xg + y * yg + 0.5;
        a->blue = x * xb + y * yb + 0.5;
      }
      else
      {
        a->red = x * xr + y * yr + 0.333333;
        a->green = x * xg + y * yg + 0.333333;
        a->blue = x * xb + y * yb + 0.333333;
      }
      /* printf("angle = %f * pi, r=%7f, g = %7f, b = %7f\n", angle / PI, a->red, a->green, a->blue); */
    }
    a = a->next;
  }
}


void phyl_free_attrlist(PHYL_LEAFATTRIBUTE *attrlist)
{
  PHYL_LEAFATTRIBUTE *a;

  while (attrlist)
  {
    a = attrlist;
    attrlist = attrlist->next;
    free(a);
  }
}


int phyl_read_leafattrs(FILE *f, PHYL_LEAFATTRIBUTE **attr)
{
  char buf[MAX_LINELENGTH], *c;
  long i, j;
  PHYL_LEAFATTRIBUTE **a;

  a = attr;
  while (!feof(f) && !ferror(f))
  {
    read_string(buf, MAX_LINELENGTH, f);
    if (buf[0])
    {
      *a = (PHYL_LEAFATTRIBUTE *) malloc(sizeof(PHYL_LEAFATTRIBUTE));
      if (*a == NULL)
        return (PHYLERR_MEM);
      (*a)->next = NULL;
      (*a)->name[0] = '\0';
      (*a)->class[0] = '\0';
      (*a)->species[0] = '\0';
      (*a)->printname[0] = '\0';
      (*a)->red = 0.0;
      (*a)->green = 0.0;
      (*a)->blue = 0.0;
      (*a)->box_red = -1.0;
      (*a)->box_green = -1.0;
      (*a)->box_blue = -1.0;
      for (i = 0; buf[i] && (buf[i] != '|') && (i < PHYL_MAX_NODENAMELENGTH - 1); i++)
        (*a)->name[i] = buf[i];
      (*a)->name[i] = '\0';
      while (buf[i] && (buf[i] != '|'))
        i++;
      if (buf[i] == '\0')
        return (PHYLERR_PARSE);
      i++;
      j = 0;
      for ( ; buf[i] && (buf[i] != '|') && (i < PHYL_MAX_NODENAMELENGTH - 1); i++)
        (*a)->class[j++] = buf[i];
      (*a)->class[j] = '\0';
      while (buf[i] && (buf[i] != '|'))
        i++;
      if (buf[i] == '|')
        i++;
      while (buf[i])
      {
        while (isspace(buf[i]))
          i++;
        i++;
        switch (buf[i - 1])
        {
        case 'c':
          (*a)->red = -1.0;
          while (buf[i] && isspace(buf[i]))
            i++;
          if ((buf[i] == '\0') || (buf[i] == ';'))
            break;
          (*a)->red = strtod(buf + i, &c);
          if (c == buf + i)
            return (PHYLERR_PARSE);
          i = c - buf;
          while (buf[i] && isspace(buf[i]))
            i++;
          if (buf[i] != ',')
            return (PHYLERR_PARSE);
          i++;
          (*a)->green = strtod(buf + i, &c);
          if (c == buf + i)
            return (PHYLERR_PARSE);
          i = c - buf;
          while (buf[i] && isspace(buf[i]))
            i++;
          if (buf[i] != ',')
            return (PHYLERR_PARSE);
          i++;
          (*a)->blue = strtod(buf + i, &c);
          if (c == buf + i)
            return (PHYLERR_PARSE);
          i = c - buf;
	  break;
	case 'b':
          (*a)->box_red = 1.0;
          (*a)->box_green = 1.0;
          (*a)->box_blue = 1.0;
          while (buf[i] && isspace(buf[i]))
            i++;
          if ((buf[i] == '\0') || (buf[i] == ';'))
            break;
          (*a)->box_red = strtod(buf + i, &c);
          if (c == buf + i)
            return (PHYLERR_PARSE);
          i = c - buf;
          while (buf[i] && isspace(buf[i]))
            i++;
          if (buf[i] != ',')
            return (PHYLERR_PARSE);
          i++;
          (*a)->box_green = strtod(buf + i, &c);
          if (c == buf + i)
            return (PHYLERR_PARSE);
          i = c - buf;
          while (buf[i] && isspace(buf[i]))
            i++;
          if (buf[i] != ',')
            return (PHYLERR_PARSE);
          i++;
          (*a)->box_blue = strtod(buf + i, &c);
          if (c == buf + i)
            return (PHYLERR_PARSE);
          i = c - buf;
	  break;
	case 'n':
	  while (buf[i] && (buf[i] != '\"'))
	    i++;
	  if (buf[i] == '\"')
	    i++;
	  for (j = 0; j + 1 < PHYL_PRINTNAME_LENGTH; j++)
	  {
	    if ((buf[i] == '\0') || (buf[i] == '\"'))
	      break;
	    (*a)->printname[j] = buf[i++];
	  }
	  (*a)->printname[j] = '\0';
	  while (buf[i] && (buf[i] != '\"'))
	    i++;
	  if (buf[i] != '\"')
	    return (PHYLERR_PARSE);
	  break;
	case 's':
	  while (buf[i] && (buf[i] != '\"'))
	    i++;
	  if (buf[i] == '\"')
	    i++;
	  for (j = 0; j + 1 < PHYL_SPECNAME_LENGTH; j++)
	  {
	    if ((buf[i] == '\0') || (buf[i] == '\"'))
	      break;
	    (*a)->species[j] = buf[i++];
	  }
	  (*a)->species[j] = '\0';
	  while (buf[i] && (buf[i] != '\"'))
	    i++;
	  if (buf[i] != '\"')
	    return (PHYLERR_PARSE);
	  break;
	default:
	  fprintf(stderr, "phyl_read_leafattrs: unknown option character \'%c\'\n", buf[i - 1]);
	  break;
        }
        while (buf[i] && (buf[i] != ';'))
          i++;
        if (buf[i] == ';')
          i++;
      }
      a = &((*a)->next);
    }
  }
  return (0);
}

